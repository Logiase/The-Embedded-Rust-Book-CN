## 可变全局状态

很不幸, 硬件基本是就是可变的全局状态, 这对于 Rust 开发者来说非常恐怖. 硬件独立于我们写的代码而存在, 并且可以随时被现实世界改变状态.

## 我们的规则?

我们如何和这些外设进行可靠的交互?

1. 始终使用 `volatile` 方法读取或写入外设内存, 因为它随时可能发生变化
2. 在软件中, 我们应该只共享这些外设的不可变引用
3. 如果某些软件需要对外设进行读写, 则应该保留对该外设的唯一引用

## 引用检查器

这些规则的最后两条听起来很想引用检查器已经在做的事情!

想象一下我们是否可以放弃对这些外设的所有权, 或者只是用可变或者不可变的引用?

好吧, 我们可以, 但是对于引用检查器, 我们需要每个外设都存在一个唯一实例, 来让 Rust 正确处理引用检查. 幸运的是, 在硬件中任何外设都只有一个实例, 但是如何在代码中展示出来呢?
