<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>嵌入式Rust之书</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> 引言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/hardware.html"><strong aria-hidden="true">1.1.</strong> 硬件</a></li><li class="chapter-item expanded "><a href="intro/no-std.html"><strong aria-hidden="true">1.2.</strong> no_std</a></li><li class="chapter-item expanded "><a href="intro/tooling.html"><strong aria-hidden="true">1.3.</strong> 工具</a></li><li class="chapter-item expanded "><a href="intro/install.html"><strong aria-hidden="true">1.4.</strong> 安装</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/install/linux.html"><strong aria-hidden="true">1.4.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="intro/install/macos.html"><strong aria-hidden="true">1.4.2.</strong> MacOS</a></li><li class="chapter-item expanded "><a href="intro/install/windows.html"><strong aria-hidden="true">1.4.3.</strong> Windows</a></li><li class="chapter-item expanded "><a href="intro/install/verify.html"><strong aria-hidden="true">1.4.4.</strong> 验证安装</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="start/index.html"><strong aria-hidden="true">2.</strong> 开始</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/qemu.html"><strong aria-hidden="true">2.1.</strong> QEMU</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">嵌入式Rust之书</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#引言" id="引言">引言</a></h1>
<p>欢迎阅读嵌入式Rust之书, 本书是使用Rust在如微控制器(MCU)的&quot;裸金属&quot;嵌入式系统上编程的引导</p>
<h2><a class="header" href="#谁应使用rust进行嵌入式开发" id="谁应使用rust进行嵌入式开发">谁应使用Rust进行嵌入式开发</a></h2>
<p>嵌入式Rust为任何想要在嵌入式系统上享受Rust提供的高级功能及安全性的人所提供.
(也可以看看<a href="https://doc.rust-lang.org/book/ch00-00-introduction.html">Who Rust Is For</a>)</p>
<h2><a class="header" href="#概览" id="概览">概览</a></h2>
<p>这本书的目标是:</p>
<ul>
<li>
<p>让开发者开苏上手Rust嵌入式开发. 例如, 如何建立开发环境</p>
</li>
<li>
<p>分享<em>当前</em>使用Rust进行嵌入式开发的最佳实践. 例如, 如何最好地使用Rust编写更加正确的嵌入式应用</p>
</li>
<li>
<p>在某些情况下提供一个开发指南. 例如, 如何在一个项目中混用C与Rust</p>
</li>
</ul>
<p>本书试着尽可能涵盖各种体系, 但是为了让读者与作者~~还有翻译~~更轻松, 在所有实例中都是用ARM Cortex-M架构.
但是, 本书并不建立在读者熟悉该架构的基础上, 会在需要的地方解释架构的细节.</p>
<h2><a class="header" href="#这本书适合谁" id="这本书适合谁">这本书适合谁</a></h2>
<p>本书面向具有一定嵌入式背景或者对Rust熟悉的人, 但是我们相信每个对嵌入式Rust编程感兴趣的人都可以从本书中学到东西.
对于那些没有任何经验知识的人, 建议您阅读 &quot;先决条件&quot; 部分并且补全缺少的知识, 以便从书中获得更多知识并且提升阅读体验.
你可以查看 &quot;其他资源&quot; 部分来查找你想获得的知识对应资源.</p>
<h3><a class="header" href="#先决条件" id="先决条件">先决条件</a></h3>
<ul>
<li>
<p>你对使用Rust很熟悉, 并且在桌面环境Rust程序写过, 跑过, 捉过虫.
对Rust2018版本熟悉, 应为本书使用Rust 2018</p>
</li>
<li>
<p>熟悉使用其他语言, 如C, C++, Ada开发调试嵌入式系统, 熟悉如以下概念:</p>
<ul>
<li>交叉编译</li>
<li>内存映射外设</li>
<li>中断</li>
<li>通用接口, 如I2C, SPI, 串口等</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#其他资源" id="其他资源">其他资源</a></h3>
<p>如果你对上面提到的东西不熟, 或者你想对本书提到的一个概念有更加深刻的了解, 你可以看看下面这些资源, 会很有用.</p>
<table><thead><tr><th>Topic</th><th>Resource</th><th>Description</th></tr></thead><tbody>
<tr><td>Rust</td><td><a href="https://doc.rust-lang.org/book/">Rust Book</a></td><td>If you are not yet comfortable with Rust, we highly suggest reading this book.</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org/discovery/">Discovery Book</a></td><td>If you have never done any embedded programming, this book might be a better start</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org">Embedded Rust Bookshelf</a></td><td>Here you can find several other resources provided by Rust's Embedded Working Group.</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org/embedonomicon/">Embedonomicon</a></td><td>The nitty gritty details when doing embedded programming in Rust.</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org/faq.html">embedded FAQ</a></td><td>Frequently asked questions about Rust in an embedded context.</td></tr>
<tr><td>Interrupts</td><td><a href="https://en.wikipedia.org/wiki/Interrupt">Interrupt</a></td><td>-</td></tr>
<tr><td>Memory-mapped IO/Peripherals</td><td><a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">Memory-mapped I/O</a></td><td>-</td></tr>
<tr><td>SPI, UART, RS232, USB, I2C, TTL</td><td><a href="https://electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-ttl-etc-what-are-all-of-these-and-how-do-th">Stack Exchange about SPI, UART, and other interfaces</a></td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#怎么看这本书" id="怎么看这本书">怎么看这本书</a></h2>
<p>这本书默认你从头看到尾. 后面的章节建立在前面的基础上, 并且前面的章节不会深挖某个细节部分, 在后面会重新探讨这个问题</p>
<p>这本书使用ST公司的<a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a>开发板作为例子.
这个开发板时ARM Cortex-M架构, 尽管基于该架构的大多数CPU的基本功能都是相似的, 但是不同供应商之间的MCU的外设与其他市县细节是不同的, 并且同意供应商之间的MCU也往往有所不同.</p>
<p>出于这个原因, 我们建议你买一块<a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a>开发板来跟着学习本书中的例子.</p>
<h2><a class="header" href="#为本书做贡献" id="为本书做贡献">为本书做贡献</a></h2>
<p>本书在<a href="https://github.com/rust-embedded/book">this repository</a>一起编写并且主要由<a href="https://github.com/rust-embedded/wg#the-resources-team">resources team</a>编写</p>
<p>如果你跟不住本书或是发现本书中某些部分不够清晰明白或者很难学习, 拿着就是一个BUG并且应该在<a href="https://github.com/rust-embedded/book/issues/">the issue tracker</a>被汇报</p>
<p>欢迎修改文字错误或是增加内容</p>
<h2><a class="header" href="#中文翻译" id="中文翻译">中文翻译</a></h2>
<p>本书为作者抽空翻译,可能有语义不通顺,如有不明白的地方也请参考<a href="https://rust-embedded.github.io/book/#introduction">英文原版</a></p>
<p>如果有勘误, 欢迎提出你的想法</p>
<p><del>同时也复习考研英语</del></p>
<p>本书<a href="https://github.com/Logiase/The-Embedded-Rust-Book-CN">仓库</a></p>
<p>时刻欢迎批评与建议</p>
<h2><a class="header" href="#重用本书资源" id="重用本书资源">重用本书资源</a></h2>
<p>本书在以下LICENSES下发布</p>
<ul>
<li>
<p>代码示例与Cargo项目均在<a href="https://opensource.org/licenses/MIT">MIT License</a>与<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License v2.0</a>下发布</p>
</li>
<li>
<p>本书的文字内容, 图片与图标均根据<a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a>条款获得许可</p>
</li>
</ul>
<p>太长别看系列: 如果你想在你的作品中使用我们的文字或图片, 你应该:</p>
<ul>
<li>加个提醒, 像是提一下本书, 再加个链接</li>
<li>提供<a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a>的链接</li>
<li>说明你是否对内容进行了修改, 并且用相同的协议对进行更改</li>
</ul>
<p>另外请一定让我们知道这本书帮了你 :gift:</p>
<h1><a class="header" href="#硬件" id="硬件">硬件</a></h1>
<p>先让我们熟悉一下陪我们的开发板</p>
<h2><a class="header" href="#stm32f3discovery-f3" id="stm32f3discovery-f3">STM32F3DISCOVERY (&quot;F3&quot;)</a></h2>
<p align="center">
<img title="F3" src="intro/../assets/f3.jpg">
</p>
<p>这块板子上都有什么?</p>
<ul>
<li><a href="https://www.st.com/en/microcontrollers/stm32f303vc.html">STM32F303VCT6</a> mcu. 这块芯片有:
<ul>
<li>支持单精度浮点的单核ARM Cortex-M4F处理器</li>
<li>256 KiB 闪存 (1 KiB = 10<strong>24</strong> bytes)</li>
<li>48 KiB RAM</li>
<li>很多集成外设, 如 计时器, I2C, SPI, USART</li>
<li>通过标有&quot;USB USER&quot;的USB接口</li>
</ul>
</li>
<li>一个<a href="https://en.wikipedia.org/wiki/Accelerometer">加速度传感器</a> <a href="https://www.st.com/en/mems-and-sensors/lsm303dlhc.html">LSM303DLHC</a></li>
<li>一个<a href="https://en.wikipedia.org/wiki/Magnetometer">磁强计</a> <a href="https://www.st.com/en/mems-and-sensors/lsm303dlhc.html">LSM303DLHC</a></li>
<li>一个<a href="https://en.wikipedia.org/wiki/Gyroscope">陀螺仪</a> <a href="https://www.pololu.com/file/0J563/L3GD20.pdf">L3GD20</a></li>
<li>8个呈指南针排列的LED</li>
<li>第二个mcu <a href="https://www.st.com/en/microcontrollers/stm32f103cb.html">STM32F103</a>. 实际上是片上编程\调试器ST-LINK的一部分</li>
</ul>
<p>关于这块板子更进一步的详细信息, 请参阅<a href="https://www.st.com/en/evaluation-tools/stm32f3discovery.html">STMicroelectronics</a></p>
<p>警告!: 如果你相对板子施加外部信号, 一定要小心! STM32F303VCT6引脚能承受的电压为3.3V. 更多有关信息, 请参阅用户手册中<a href="https://www.st.com/resource/en/datasheet/stm32f303vc.pdf">6.2 Absolute maximum ratings section in the manual</a></p>
<h1><a class="header" href="#一个-no_std-的rust环境" id="一个-no_std-的rust环境">一个 <code>no_std</code> 的Rust环境</a></h1>
<p>嵌入式编程一词用于很多不同种类的涵义. 从只有几KB大小RAM与ROM的8位MCU, 到像是树莓派这样有32/64位四核Cortex-A53 cpu与1GB内存的设备.
编写代码时, 对于不同设备会有不同的限制.</p>
<p>有两种通用的嵌入式变成分类:</p>
<h2><a class="header" href="#托管环境" id="托管环境">托管环境</a></h2>
<p>这种环境与正常的PC环境相似. 这意味这你能够使用系统级接口, 类似POSIX这样的能提供给你与系统交互的原语, 像是文件系统, 网络, 内存管理, 线程等等.
你可能还会有些sysroot和RAM/ROM的限制, 可能还会有些特殊的硬件或I/O. 简而言之, 这类似在一台特殊用途的PC环境上编程.</p>
<h2><a class="header" href="#裸金属" id="裸金属">裸金属</a></h2>
<p>在一个裸金属环境中, 在你的程序开始之前不会有任何代码被加载.
没有OS提供我们没法使用标准库.
相反, 程序和它使用的库(Crates)可以只使用硬件(裸金属)来运行.
为了防止rust使用标准库, 我们使用<code>no_std</code>.
标准库中与平台无关的部分可以通过<a href="https://doc.rust-lang.org/core/">libcore</a>获取.
libcore中也排除了在嵌入式环境中并不总是理想的东西.
这其中之一就是用于动态内存分配的内存分配器.
如果你需要这个或是其他功能, 会有库(Crates)提供.</p>
<h3><a class="header" href="#libstd运行时" id="libstd运行时">libstd运行时</a></h3>
<p>像前面说的, 使用<a href="https://doc.rust-lang.org/std/">libstd</a>需要系统支持, 但是这并不只是因为<a href="https://doc.rust-lang.org/std/">libstd</a>至提供了访问OS的通用的抽象的方法, 而且它还提供了一个运行时.
这个运行时, 除了其他事情外, 还负责设置对战一处保护, 处理命令行参数还有在调用程序的main函数之前创建主线程. 这个运行时在<code>no_std</code>环境中不可用.</p>
<h2><a class="header" href="#总结" id="总结">总结</a></h2>
<p><code>#![no_std]</code>是一个声明这个crate不会连接到std-crate二十core-crate的crate级别的属性.
<a href="https://doc.rust-lang.org/core/">libcore</a>是std-crate的一个与平台无关的子集, 对程序将要运行在的系统上没有任何假设(需求).
因此, 它为语言原语,像是float, string和slices等提供api, 和开放的处理器特性, 像是原子操作与SIMD指令.
然而他缺少任何设计平台集成的API.
由于这些属性, no_std与<a href="https://doc.rust-lang.org/core/">libcore</a>写成的代码能不能够用于任何类型的引导(stage 0)像是加载程序, 固件还有内核.</p>
<h3><a class="header" href="#概述" id="概述">概述</a></h3>
<table><thead><tr><th>feature</th><th>no_std</th><th>std</th></tr></thead><tbody>
<tr><td>堆 (动态内存)</td><td>*</td><td>✓</td></tr>
<tr><td>集合 (Vec, HashMap, etc)</td><td>**</td><td>✓</td></tr>
<tr><td>堆栈溢出保护</td><td>✘</td><td>✓</td></tr>
<tr><td>初始化函数</td><td>✘</td><td>✓</td></tr>
<tr><td>libstd  可用</td><td>✘</td><td>✓</td></tr>
<tr><td>libcore 可用</td><td>✓</td><td>✓</td></tr>
<tr><td>编写 固件, 内核, 引导加载器</td><td>✓</td><td>✘</td></tr>
</tbody></table>
<p>* 只有当你使用 <code>alloc</code> crate并且选择一个合适的分配器, 像是<a href="https://github.com/rust-embedded/alloc-cortex-m">alloc-cortex-m</a>才可用.</p>
<p>** 只有当你使用 <code>collections</code> crate 并且配置一个全局默认的分配器才可用</p>
<h2><a class="header" href="#see-also" id="see-also">See Also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md">RFC-1184</a></li>
</ul>
<h1><a class="header" href="#工具" id="工具">工具</a></h1>
<p>处理微控制器涉及到使用集中不同的工具, 因为我们要处理一个与你电脑架构不同的架构, 我们必须要在远程设备上来运行和调试程序.</p>
<p>我们会使用下面列出的工具. 没指定最低版本时, 按理说任何最新版本都能用, 但是我们也列出了经过测试的版本.</p>
<ul>
<li>Rust 1.31, 1.31-beta, 或带有 ARM Cortex-M 编译器的更新的工具链</li>
<li><a href="https://github.com/rust-embedded/cargo-binutils"><code>cargo-binutils</code></a> ~0.1.4</li>
<li><a href="https://www.qemu.org/"><code>qemu-system-arm</code></a>. 测试版本: 3.0.0</li>
<li>OpenOCD &gt;=0.8. 测试版本: v0.9.0 and v0.10.0</li>
<li>GDB with ARM support. 7.12或更高版本. 测试版本: 7.10, 7.11, 7.12 and 8.1</li>
<li><a href="https://github.com/ashleygwilliams/cargo-generate"><code>cargo-generate</code></a> 或 <code>git</code>.
这个工具可选但是会让你学习本书更加轻松.</li>
</ul>
<p>下面来讲为什么我们需要这些工具. 安装说明会在下一页提及.</p>
<h2><a class="header" href="#cargo-generate-或-git" id="cargo-generate-或-git"><code>cargo-generate</code> 或 <code>git</code></a></h2>
<p>裸金属应用是不标准(<code>no_std</code>)的Rust程序, 需要对链接过程做出一些调整, 以使程序的内存布局正确. 这需要一些额外的文件(像是链接器脚本)和设置(像是连接器参数).
我们已经把这些打包成了一个模板, 这样你就只需要填写确实的信息就行(就想项目名称和目标硬件型号).</p>
<p>我们的模板与<code>cargo-generate</code>兼容, <code>cargo-generate</code>是Cargo的一个子命令, 用来从模板创建新的Cargo项目. 你也可以使用<code>git</code>, <code>curl</code>, <code>wget</code>或浏览器来下载模板.</p>
<h2><a class="header" href="#cargo-binutils" id="cargo-binutils"><code>cargo-binutils</code></a></h2>
<p><code>cargo-binutils</code>是Cargo的一系列子命令, 用来更轻松的配合Rust工具链使用LLVM工具. 这些工具包含LLVM版本的<code>objdump</code>, <code>nm</code>和<code>size</code>, 用来检查二进制产物.</p>
<p>与GNU binmutils相比, 使用这些工具的优势在于, (a) 可以无视系统一键安装LLVM工具(<code>rustup component add llvm-tools-preview</code>), (b) 像<code>objdump</code>这样的工具支持所有<code>rustc</code>支持的所有架构, 从 ARM 到 x86_64 应为他们都使用了相同的LLVM后端.</p>
<h2><a class="header" href="#qemu-system-arm" id="qemu-system-arm"><code>qemu-system-arm</code></a></h2>
<p>QEMU是个模拟器. 在本书中, 我们使用能够模拟各种ARM系统的变体.
我们使用QEMU来在电脑上运行嵌入式程序.
多亏这个, 你能在没有硬件的情况下学习本书.</p>
<h2><a class="header" href="#gdb" id="gdb">GDB</a></h2>
<p>调试器是嵌入式开发中非常重要的一个组件, 因为你并不总是有足够的空间去把气质打到控制台上.
某些情况下, 你的硬件上甚至都没有LED可以闪(呜呜呜).</p>
<p>通常情况下, 涉及到调试的时候, LLDB和GDB差不多, 但是我们还没找到一个与GDB的<code>load</code>命令相同功能的LLDB指令, 这个命令把程序加载到硬件上, 所以我们建议你使用GDB.</p>
<h2><a class="header" href="#openocd" id="openocd">OpenOCD</a></h2>
<p>GDB现在还不能直接通过ST-Link调试器和你的STM32F3DISCOVERY开发板沟通.
他需要一个翻译器, Open On-Chip Debugger 缩写 OpenOCD 就是这个翻译器.
OpenOCD是在你电脑上运行的, 可以在GDB基于TCP/IP的远程调试协议和ST-LINK基于USB的协议之间进行转换.</p>
<p>OpenOCD还执行其他工作, 作为翻译的一部分, 用于调试STM32F3DISCOVERY开发板上的ARM Cortex-M处理器.</p>
<ul>
<li>他知道如何与ARM CoreSight调试外围设备使用的内存映射寄存器沟通.正是这些CoreSight寄存器允许:
<ul>
<li>断电/观察点操作</li>
<li>读写CPU寄存器</li>
<li>检测CPU何时银调试而暂停</li>
<li>在调试结束后继续CPU执行</li>
<li>更多.</li>
</ul>
</li>
<li>它还知道如何擦除和覆写mcu的flash</li>
</ul>
<h1><a class="header" href="#安装工具" id="安装工具">安装工具</a></h1>
<p>此页包含与操作系统无关的工具安装说明:</p>
<h3><a class="header" href="#rust-工具链" id="rust-工具链">Rust 工具链</a></h3>
<p>按照<a href="https://rustup.rs">https://rustup.rs</a>的教程安装rustup.</p>
<p><strong>NOTE</strong> 确保你有<code>1.31</code>或以上版本的编译器. <code>rustc -V</code>应该返回一个更新的版本.</p>
<pre><code class="language-console">$ rustc -V
rustc 1.31.1 (b6c32da9b 2018-12-18)
</code></pre>
<p>为了带宽和磁盘的使用情况, 默认安装只支持本机编译.
要想添加ARM Cortex-M的交叉编译支持, 应该选择下面其一的编译目标.
对于STM32F3DISCOVERY开发板, 应该使用<code>thumbv7em-none-eabihf</code></p>
<p>Cortex-M0, M0+, M1 (ARMv6-M 架构):</p>
<pre><code class="language-console">$ rustup target add thumbv6m-none-eabi
</code></pre>
<p>Cortex-M3 (ARMv7-M 架构):</p>
<pre><code class="language-console">$ rustup target add thumbv7m-none-eabi
</code></pre>
<p>没有硬浮点的Cortex-M4 and M7 (ARMv7E-M 架构):</p>
<pre><code class="language-console">$ rustup target add thumbv7em-none-eabi
</code></pre>
<p>有硬浮点的Cortex-M4F and M7F (ARMv7E-M 架构):</p>
<pre><code class="language-console">$ rustup target add thumbv7em-none-eabihf
</code></pre>
<p>Cortex-M23 (ARMv8-M 架构):</p>
<pre><code class="language-console">$ rustup target add thumbv8m.base-none-eabi
</code></pre>
<p>Cortex-M33 and M35P (ARMv8-M 架构):</p>
<pre><code class="language-console">$ rustup target add thumbv8m.main-none-eabi
</code></pre>
<p>有硬浮点的Cortex-M33F and M35PF (ARMv8-M 架构):</p>
<pre><code class="language-console">$ rustup target add thumbv8m.main-none-eabihf
</code></pre>
<h3><a class="header" href="#cargo-binutils-1" id="cargo-binutils-1"><code>cargo-binutils</code></a></h3>
<pre><code class="language-console">$ cargo install cargo-binutils

$ rustup component add llvm-tools-preview
</code></pre>
<h3><a class="header" href="#cargo-generate" id="cargo-generate"><code>cargo-generate</code></a></h3>
<p>我们后面用这个来生成项目</p>
<pre><code class="language-console">$ cargo install cargo-generate
</code></pre>
<h3><a class="header" href="#os相关安装" id="os相关安装">OS相关安装</a></h3>
<p>现在跟着这些教程安装:</p>
<ul>
<li><a href="intro/install/linux.html">Linux</a></li>
<li><a href="intro/install/windows.html">Windows</a></li>
<li><a href="intro/install/macos.html">macOS</a></li>
</ul>
<h1><a class="header" href="#linux" id="linux">Linux</a></h1>
<p>如下是对几种发行版的安装命令</p>
<h2><a class="header" href="#包" id="包">包</a></h2>
<ul>
<li>Ubuntu 18.04 及以上 / Debian stretch 及以上</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code>gdb-mutliarch</code> 是你debug你的ARM Cortex-M程序的GDB命令</p>
</blockquote>
<!-- Debian stretch -->
<!-- GDB 7.12 -->
<!-- OpenOCD 0.9.0 -->
<!-- QEMU 2.8.1 -->
<!-- Ubuntu 18.04 -->
<!-- GDB 8.1 -->
<!-- OpenOCD 0.10.0 -->
<!-- QEMU 2.11.1 -->
<pre><code class="language-console">sudo apt install gdb-multiarch openocd qemu-system-arm
</code></pre>
<ul>
<li>Ubuntu 14.04 , 16.04</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> 是你debug你的ARM Cortex-M程序的GDB命令</p>
</blockquote>
<!-- Ubuntu 14.04 -->
<!-- GDB 7.6 (!) -->
<!-- OpenOCD 0.7.0 (?) -->
<!-- QEMU 2.0.0 (?) -->
<pre><code class="language-console">sudo apt install gdb-arm-none-eabi openocd qemu-system-arm
</code></pre>
<ul>
<li>Fedora 27 及以上</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> 是你debug你的ARM Cortex-M程序的GDB命令</p>
</blockquote>
<!-- Fedora 27 -->
<!-- GDB 7.6 (!) -->
<!-- OpenOCD 0.10.0 -->
<!-- QEMU 2.10.2 -->
<pre><code class="language-console">sudo dnf install arm-none-eabi-gdb openocd qemu-system-arm
</code></pre>
<ul>
<li>Arch Linux</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> 是你debug你的ARM Cortex-M程序的GDB命令</p>
</blockquote>
<pre><code class="language-console">sudo pacman -S arm-none-eabi-gdb qemu-arch-extra openocd
</code></pre>
<h2><a class="header" href="#udev规则" id="udev规则">udev规则</a></h2>
<p>这条规则让你可以使用OpenOCD而不要root权限.</p>
<p>在<code>/etc/udev/rules.d/70-st-link.rules</code>创建文件, 并写入以下内容.</p>
<pre><code class="language-text"># STM32F3DISCOVERY rev A/B - ST-LINK/V2
ATTRS{idVendor}==&quot;0483&quot;, ATTRS{idProduct}==&quot;3748&quot;, TAG+=&quot;uaccess&quot;

# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1
ATTRS{idVendor}==&quot;0483&quot;, ATTRS{idProduct}==&quot;374b&quot;, TAG+=&quot;uaccess&quot;
</code></pre>
<p>然后重新加载udev规则</p>
<pre><code class="language-console">sudo udevadm control --reload-rules
</code></pre>
<p>如果你把板子连接到了电脑, 重新连接.</p>
<p>使用如下命令检查权限:</p>
<pre><code class="language-console">lsusb
</code></pre>
<p>你应该看到如下内容:</p>
<pre><code class="language-text">(..)
Bus 001 Device 018: ID 0483:374b STMicroelectronics ST-LINK/V2.1
(..)
</code></pre>
<p>记一下总线设备号. 用这些数字来创建如下目录<code>/dev/bus/usb/&lt;bus&gt;/&lt;device&gt;</code>. 然后链接目录:</p>
<pre><code class="language-console">ls -l /dev/bus/usb/001/018
</code></pre>
<pre><code class="language-text">crw-------+ 1 root root 189, 17 Sep 13 12:34 /dev/bus/usb/001/018
</code></pre>
<pre><code class="language-console">getfacl /dev/bus/usb/001/018 | grep user
</code></pre>
<pre><code class="language-text">user::rw-
user:you:rw-
</code></pre>
<p>附加在权限后面的<code>+</code>表示存在扩展权限。<code>getfacl</code>命令告诉用户<code>您</code>可以使用这个设备。</p>
<p>现在阅读<a href="intro/install/verify.html">下一部分</a></p>
<h1><a class="header" href="#macos" id="macos">macOS</a></h1>
<p>所有工具都可以用<a href="http://brew.sh/">Homebrew</a>安装:</p>
<pre><code class="language-console">$ # GDB
$ brew install armmbed/formulae/arm-none-eabi-gcc

$ # OpenOCD
$ brew install openocd

$ # QEMU
$ brew install qemu
</code></pre>
<p>这就是全部了, <a href="intro/install/verify.html">下一部分</a>.</p>
<h1><a class="header" href="#windows" id="windows">Windows</a></h1>
<h2><a class="header" href="#arm-none-eabi-gdb" id="arm-none-eabi-gdb"><code>arm-none-eabi-gdb</code></a></h2>
<p>ARM为Windows提供了<code>.exe</code>安装器. 从这<a href="https://xpack.github.io/openocd/">openocd</a>: <a href="https://xpack.github.io/openocd/">https://xpack.github.io/openocd/</a>下载<a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">here</a>, 然后跟着说i名安装.
在安装结束之前选择&quot;添加到环境变量&quot;选项. 然后验证工具已经在<code>%PATH%</code>中:</p>
<pre><code class="language-console">$ arm-none-eabi-gdb -v
GNU gdb (GNU Tools for Arm Embedded Processors 7-2018-q2-update) 8.1.0.20180315-git
(..)
</code></pre>
<h2><a class="header" href="#openocd-1" id="openocd-1">OpenOCD</a></h2>
<p>对Windows现在还没有官方的二进制文件, 但是如果你不想自己编译, xPack项目提供了一个二进制文件. <a href="https://xpack.github.io/openocd/">here</a>. 跟着安装说明. 然后更新你的<code>%PATH%</code>环境变量. (如果你使用快速安装<code>C:\Users\USERNAME\AppData\Roaming\xPacks\@xpack-dev-tools\openocd\0.10.0-13.1\.content\bin\</code>)</p>
<p>验证OpenOCD已经在<code>%PATH%</code>中:</p>
<pre><code class="language-console">$ openocd -v
Open On-Chip Debugger 0.10.0
(..)
</code></pre>
<h2><a class="header" href="#qemu" id="qemu">QEMU</a></h2>
<p>从<a href="https://www.qemu.org/download/#windows">官方网站</a>获取QEMU.</p>
<h2><a class="header" href="#st-link-usb驱动" id="st-link-usb驱动">ST-LINK USB驱动</a></h2>
<p>你还需要安装<a href="http://www.st.com/en/embedded-software/stsw-link009.html">USB驱动</a>, 否则OpenOCD不能工作. 跟着安装说明并且保证你安装了正确的版本(32位或64位).</p>
<p>这就是全部了, <a href="intro/install/verify.html">下一部分</a></p>
<h1><a class="header" href="#验证安装" id="验证安装">验证安装</a></h1>
<p>在这一部分我们检查需要的工具/驱动是否被正确安装. </p>
<p>把Discovery开发板连接到电脑. Discovery有两个USB口, 使用在板子中间标着&quot;USB ST-LINK&quot;的口.</p>
<p>也检查ST-LINK的接口是否被污染. 看如下图片, ST-LINK接口被红线圈中.</p>
<p align="center">
<img title="Connected discovery board" src="intro/install/../../assets/verify.jpeg">
</p>
<p>现在运行如下命令:</p>
<pre><code class="language-console">$ openocd -f interface/stlink.cfg -f target/stm32f3x.cfg
</code></pre>
<p>你应该会得到如下输出并且命令行被阻塞:</p>
<pre><code class="language-text">Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport &quot;hla_swd&quot;. To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.919881
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<p>内容并不会完全一样, 但你应该会看到有关断点和观察点的最后一行.
如果没什么问题那就关掉OpenOCD然后到<a href="intro/install/../../start/index.html">下一部分</a>.</p>
<p>如果你没看到 &quot;断点&quot; 这一行, 那试试如下命令.</p>
<pre><code class="language-console">$ openocd -f interface/stlink-v2.cfg -f target/stm32f3x.cfg
</code></pre>
<pre><code class="language-console">$ openocd -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg
</code></pre>
<p>如果有一条命令成功了, 这意味这你手上的是个旧版本Discovery. 那不会有什么问题, 除了内存设置会在后面有些不同, 到<a href="intro/install/../../start/index.html">下一部分</a>.</p>
<p>如果这些命令都用不了, 那就试试使用root权限(像是<code>sudo openocd ...</code>). 如果命令能够执行, 那么检查一下<a href="intro/install/linux.html#udev%E8%A7%84%E5%88%99">udev规则</a>是否正确. </p>
<p>如果到这, 你的OpenOCD还是不能用, 那就来发个<a href="https://github.com/rust-embedded/book/issues">issue</a>然后我们来帮你!</p>
<h1><a class="header" href="#开始" id="开始">开始</a></h1>
<p>在这一部分, 我们会带你写代码, 编译, 烧录, 调试嵌入式程序.
我们会教你QEMU的基础, 一个开源的硬件模拟器, 因此你能不用硬件来运行大部分例子.
很自然的, 唯一需要硬件的章节就是<a href="start/./hardware.html">硬件</a>, 在这部分我们使用OpenOCD在<a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a></p>
<h1><a class="header" href="#qemu-1" id="qemu-1">QEMU</a></h1>
<p>我们要开始给<a href="http://www.ti.com/product/LM3S6965">LM3S6965</a>编程, <a href="http://www.ti.com/product/LM3S6965">LM3S6965</a>是一个Cortex-M3微控制器.
我们选择这个作为开始是应为它能被QEMU<a href="https://wiki.qemu.org/Documentation/Platforms/ARM#Supported_in_qemu-system-arm">模拟</a>,所以你不必在本部分玩弄硬件,专心与工具与编程.</p>
<p><strong>Important</strong>
在本教程中我们使用&quot;app&quot;作为项目名.
当你看到&quot;app&quot;这个词的时候,你应该把它换成你给你自己的项目起的名.
或者,你就可以把你的项目名设成&quot;app&quot;.</p>
<h2><a class="header" href="#创建一个不含标准库的rust程序" id="创建一个不含标准库的rust程序">创建一个不含标准库的Rust程序</a></h2>
<p>我们会使用<a href="https://github.com/rust-embedded/cortex-m-quickstart"><code>cortex-m-quickstart</code></a>项目模板来生成一个新项目.
新创建的项目会包含一个基础结构:
一个对嵌入式Rust程序的好的开始.
这个项目还额外包括一个有着几个不同例子的<code>example</code>文件夹.</p>
<h3><a class="header" href="#使用-cargo-generate" id="使用-cargo-generate">使用 <code>cargo-generate</code></a></h3>
<p>首先安装 cargo-generate</p>
<pre><code class="language-console">cargo install cargo-generate
</code></pre>
<p>然后生成一个新项目</p>
<pre><code class="language-console">cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart
</code></pre>
<pre><code class="language-text"> Project Name: app
 Creating project called `app`...
 Done! New project created /tmp/app
</code></pre>
<pre><code class="language-console">cd app
</code></pre>
<h3><a class="header" href="#使用git" id="使用git">使用<code>git</code></a></h3>
<p>克隆仓库</p>
<pre><code class="language-console">git clone https://github.com/rust-embedded/cortex-m-quickstart app
cd app
</code></pre>
<p>然后修改<code>Cargo.toml</code>中的占位符</p>
<pre><code class="language-toml">[package]
authors = [&quot;{{authors}}&quot;] # &quot;{{authors}}&quot; -&gt; &quot;John Smith&quot;
edition = &quot;2018&quot;
name = &quot;{{project-name}}&quot; # &quot;{{project-name}}&quot; -&gt; &quot;awesome-app&quot;
version = &quot;0.1.0&quot;

# ..

[[bin]]
name = &quot;{{project-name}}&quot; # &quot;{{project-name}}&quot; -&gt; &quot;awesome-app&quot;
test = false
bench = false
</code></pre>
<h3><a class="header" href="#两者都不用" id="两者都不用">两者都不用</a></h3>
<p>下载最新的<code>cortex-m-quickstart</code>然后解压</p>
<pre><code class="language-console">curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/master.zip
unzip master.zip
mv cortex-m-quickstart-master app
cd app
</code></pre>
<p>或者你可以打开<a href="https://github.com/rust-embedded/cortex-m-quickstart"><code>cortex-m-quickstart</code></a>,然后点绿色的&quot;Clone or download&quot;,然后选择&quot;Download ZIP&quot;.</p>
<p>然后按照第二部分&quot;使用git&quot;中修改占位符.</p>
<h2><a class="header" href="#程序概览" id="程序概览">程序概览</a></h2>
<p>为了方便,<code>src/main.rs</code>中已经有了很重要的部分:</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use panic_halt as _;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    loop {
        // your code goes here
    }
}
</code></pre>
<p>这个和标准的Rust程序不太一样,咱们来凑近一点看看.</p>
<p><code>#![no_std]</code>声明这个程序<em>不会</em>连接到<code>std</code>标准库.
作为代替会连接到<code>core</code></p>
<p><code>#![no_main]</code>声明这个程序不会使用大部分Rust使用的main函数接口.
使用<code>no_main</code>主要原因是在<code>no_std</code>中使用<code>main</code>需要每夜版的Rust.</p>
<p><code>use panic_halt as _;</code>.这个库提供一个定义panic行为的<code>panic_handler</code>.
我们会在<a href="start/panicing.html">Panicing</a>章节中讨论更多细节.</p>
<p><a href="https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.entry.html"><code>#[entry]</code></a>是一个由<a href="https://crates.io/crates/cortex-m-rt"><code>cortex-m-rt</code></a>提供的属性,用来标记程序的入口.
当我们不用标准的<code>main</code>入口我们就需要其他的方式声明程序的入口,就是<code>#[entry]</code>.</p>
<p><code>fn main() -&gt; !</code>.我们的程序<em>只会</em>运行在目标硬件上,所以我们不希望他停止!
我们使用一个<a href="https://doc.rust-lang.org/rust-by-example/fn/diverging.html">发散函数</a> (<code>-&gt;!</code>符号)来确保编译期不会出问题.</p>
<h2><a class="header" href="#交叉编译" id="交叉编译">交叉编译</a></h2>
<p>下一步是为Cortex-M3架构进行<em>交叉</em>编译.
在知道编译目标时(<code>$TRIPLE</code>)使用<code>cargo build --target $TRIPLE</code>会很方便.
很幸运,模板中的<code>.cargo/config</code>已经提供了答案.</p>
<pre><code class="language-console">tail -n6 .cargo/config
</code></pre>
<pre><code class="language-toml">[build]
# Pick ONE of these compilation targets
# target = &quot;thumbv6m-none-eabi&quot;    # Cortex-M0 and Cortex-M0+
target = &quot;thumbv7m-none-eabi&quot;    # Cortex-M3
# target = &quot;thumbv7em-none-eabi&quot;   # Cortex-M4 and Cortex-M7 (no FPU)
# target = &quot;thumbv7em-none-eabihf&quot; # Cortex-M4F and Cortex-M7F (with FPU)
</code></pre>
<p>为了给Cortex-M3架构交叉编译,我们要使用<code>thumbv7m-none-eabi</code>.
这个编译目标并不是自带的,如果你没有的话,现在就装:</p>
<pre><code class="language-console">rustup target add thumbv7m-none-eabi
</code></pre>
<p>如果<code>thumbv7m-none-eabi</code>已经<code>.cargo/config</code>中设为默认值,那下面这两条命令是一样的</p>
<pre><code class="language-console">cargo build --target thumbv7m-none-eabi
cargo build
</code></pre>
<h2><a class="header" href="#检查" id="检查">检查</a></h2>
<p>现在我们在<code>target/thumbv7m-none-eabi/debug/app</code>有一个非本机的ELF二进制文件.
我们可以用<code>cargo-binutils</code>来检查它.</p>
<p>使用<code>cargo-readobj</code>来查看ELF头来确认这是个给ARM的二进制文件.</p>
<pre><code class="language-console">cargo readobj --bin app -- -file-headers
</code></pre>
<p>注意:</p>
<ul>
<li><code>--bin app</code>是个<code>target/$TRIPLE/debug/app</code>的语法糖</li>
<li><code>--bin app</code>如果需要的话会重新编译</li>
</ul>
<pre><code class="language-text">ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0x0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x405
  Start of program headers:          52 (bytes into file)
  Start of section headers:          153204 (bytes into file)
  Flags:                             0x5000200
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         19
  Section header string table index: 18
</code></pre>
<p><code>cargo-size</code>可以打印二进制文件中连接器的部分.</p>
<pre><code class="language-console">cargo size --bin app --release -- -A
</code></pre>
<p>我们使用<code>--release</code>来获取优化的版本.</p>
<pre><code class="language-text">app  :
section             size        addr
.vector_table       1024         0x0
.text                 92       0x400
.rodata                0       0x45c
.data                  0  0x20000000
.bss                   0  0x20000000
.debug_str          2958         0x0
.debug_loc            19         0x0
.debug_abbrev        567         0x0
.debug_info         4929         0x0
.debug_ranges         40         0x0
.debug_macinfo         1         0x0
.debug_pubnames     2035         0x0
.debug_pubtypes     1892         0x0
.ARM.attributes       46         0x0
.debug_frame         100         0x0
.debug_line          867         0x0
Total              14570
</code></pre>
<blockquote>
<p>A refresher on ELF linker sections</p>
<ul>
<li><code>.text</code> contains the program instructions</li>
<li><code>.rodata</code> contains constant values like strings</li>
<li><code>.data</code> contains statically allocated variables whose initial values are
<em>not</em> zero</li>
<li><code>.bss</code> also contains statically allocated variables whose initial values
<em>are</em> zero</li>
<li><code>.vector_table</code> is a <em>non</em>-standard section that we use to store the vector
(interrupt) table</li>
<li><code>.ARM.attributes</code> and the <code>.debug_*</code> sections contain metadata and will
<em>not</em> be loaded onto the target when flashing the binary.</li>
</ul>
</blockquote>
<p><strong>IMPORTANT</strong>: ELF文件包含了类似Debug信息等等元数据,所以他们的在<em>磁盘上的大小</em>并<em>不能</em>
准确的反映烧录在硬件上的大小.<em>通常</em>使用<code>cargo-size</code>来检查二进制文件真正的大小</p>
<p><code>cargo-objdump</code>可用于反汇编二进制文件.</p>
<pre><code class="language-console">cargo objdump --bin app --release -- --disassemble --no-show-raw-insn --print-imm-hex
</code></pre>
<blockquote>
<p><strong>NOTE</strong> 如果以上命令报错<code>Unknown command line argument</code>,
可以看看这个bug: <a href="https://github.com/rust-embedded/book/issues/269">https://github.com/rust-embedded/book/issues/269</a></p>
<p><strong>NOTE</strong> 这个根据不同系统有所区别.新版本的rustc,LLVM还有库会生成不同的二进制文件.
我们删节了一些说明,意识代码段变小.</p>
</blockquote>
<pre><code class="language-text">app:  file format ELF32-arm-little

Disassembly of section .text:
main:
     400: bl  #0x256
     404: b #-0x4 &lt;main+0x4&gt;

Reset:
     406: bl  #0x24e
     40a: movw  r0, #0x0
     &lt; .. truncated any more instructions .. &gt;

DefaultHandler_:
     656: b #-0x4 &lt;DefaultHandler_&gt;

UsageFault:
     657: strb  r7, [r4, #0x3]

DefaultPreInit:
     658: bx  lr

__pre_init:
     659: strb  r7, [r0, #0x1]

__nop:
     65a: bx  lr

HardFaultTrampoline:
     65c: mrs r0, msp
     660: b #-0x2 &lt;HardFault_&gt;

HardFault_:
     662: b #-0x4 &lt;HardFault_&gt;

HardFault:
     663: &lt;unknown&gt;
</code></pre>
<h2><a class="header" href="#运行" id="运行">运行</a></h2>
<p>下一步我们要在QEMU上运行我们的嵌入式程序!
这次我们使用<code>hello</code>这个例子来搞事.</p>
<p>为了方便,如下是<code>example/hello.rs</code>的源码</p>
<pre><code class="language-rust ignore">//! Prints &quot;Hello, world!&quot; on the host console using semihosting

#![no_main]
#![no_std]

use panic_halt as _;

use cortex_m_rt::entry;
use cortex_m_semihosting::{debug, hprintln};

#[entry]
fn main() -&gt; ! {
    hprintln!(&quot;Hello, world!&quot;).unwrap();

    // exit QEMU
    // NOTE do not run this on hardware; it can corrupt OpenOCD state
    debug::exit(debug::EXIT_SUCCESS);

    loop {}
}
</code></pre>
<p>这个程序使用一个叫semihosting的东西来打印信息到<em>宿主机</em>.
等到了真正的硬件上,就需要一个调试会话才能用.</p>
<p>让我们来开始编译这个例子:</p>
<pre><code class="language-console">cargo build --example hello
</code></pre>
<p>产出的二进制文件在<code>target/thumbv7m-none-eabi/debug/examples/hello</code>.</p>
<p>为了在QEMU上运行这个应使用如下命令:</p>
<pre><code class="language-console">qemu-system-arm \
  -cpu cortex-m3 \
  -machine lm3s6965evb \
  -nographic \
  -semihosting-config enable=on,target=native \
  -kernel target/thumbv7m-none-eabi/debug/examples/hello
</code></pre>
<pre><code class="language-text">Hello, world!
</code></pre>
<p>这条命令应该在输出信息后成功推出(exit code = 0).
在*nix上你可以用如下命令确认:</p>
<pre><code class="language-console">echo $?
</code></pre>
<pre><code class="language-text">0
</code></pre>
<p>让我们来破解QEMU命令:</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
